\documentclass[thesis.tex]{subfiles}

\begin{document}
\chapter{Performance testing}
This chapter is concerned with testing the efficiency of the approach by running large scale tests on the implemented tool. There are two metrics which will be presented: The running time of the algorithm and the correctness of the achieved result. How correctness is determined is covered in section \ref{sec:performance_validation}. Most of the results are compared against running the same alignment with an own PO-MSA implementation. We chose PO-MSA because of its intuitive nature, the easily deducible relationship between graph complexity and running time and, most importantly, because it is a non-heuristical approach guaranteeing a correct result every time.
\section{Test data}
These tests are meant to reflect usage in a what would be an every day situation, and does therefore use real genetic data. All of the sequences are FASTA-files from the MHC region, most fetched from the vg github repo\cite{vg}, some from the test-set provided by the sequence graphs tool\cite{sequence_graphs}. The exact test sets are chosen to provide a variety of sequence lengths. In order to cover lengths where we found no sequences there are created artificial sequences by cutting out suitable regions from longer sequences. All the sequences which are used can be found in the test-folder of the github repo of the tool (Appendix \ref{sec:tool}).\\
\par\noindent
Specifically, there are 8 main data-sets involved in the testing process:
\begin{itemize}
  \item \textbf{mhc1.fa} A 700 bp long sequence from the MHC region (not specified more precisely where). Fetched from the docker repo of the sg project
  \item \textbf{primary.fasta} A 3345 bp long sequence from the HLA-A gene in the MHC region from the primary assembly of GRCh38. Originates from the vg github.
  \item \textbf{20k.fasta, 35k.fasta, 100k.fasta, 150k.fasta, 500k.fasta} Five subsequences of an alternate assembly of the MHC region of respectively 21.070bp, 35.770bp, 101.570bp, 144.480bp and 448.490bp. The alternate assembly originates from the NCBI database\cite{ncbi} with id NT\_167244.1.
  \item \textbf{mhc\_full.fa} The previously mentioned full mhc assembly of 4.622.290bp.
\end{itemize}
Additionally, some of the tests use more specific data, to test specific properties. This data will be presented before it is used.
\par\noindent
In order to do alignments we need reads aswell as the data used in building the reference structure. These reads are generated by the read-generator seen in the appendix. A read $r$ from a graph $G$ is generated by the following procedure:
\begin{enumerate}
  \item Choose a random vertice $v \in G\setminus\{s_G, t_G\}$ such that the smallest distance from $v$ to $t_g$ is larger than the chosen read size $|r|$
  \item For $|r|$ steps:
  \begin{enumerate}
    \item Append $b(v_x)$ to the read $r$
    \item Choose a random neighbouring vertice $v_y \in neighbours(v_x)$ as the new $v_x$
  \end{enumerate}
  \item When a read $r$ has been generated, for $r_i \in r$
  \begin{enumerate}
    \item Choose a random floating point value $0<=v<=1$
    \begin{itemize}
      \item If $v<(p/3)$ delete $r_i$
      \item Else if $v<(2p/3)$ insert a random base $b \in \{A, C, G, T\}$ before $r_i$
      \item Else if $v<p$ substitue $r_i$ with a random base $b \in \{A, C, G, T\} \\ \{r_i\}$
    \end{itemize}
  \end{enumerate}
  \item Output $r$
\end{enumerate}
In order to provide reproducability the randomness in the reads are generated from a seed.\\
\par\noindent
Because this thesis is concerned with the mathematical properties of the model the noise in the reads does not necessarily depict the true nature of either genetic variation (Section \ref{sec:genetic_variation}) or read errors (Section \ref{sec:sequencing}). This is one of the points where we have chosen to limit the complexity of the problem. We argue is an acceptable limitation by seeing these as specifications of a more general problem, \textcolor{red}{more}
\section{Validation}
\label{sec:performance_validation}
When an alignment is produced for a read we classify it as either as correct or not correct. Intuitively one could imagine this can be figured out by determining whether the generated read aligns back to the path it was generated from. However, when noise is introduced an interesting phenomenon can occur: The modified read can become more similar to another path in the graph than its origin. This can also occur whenever there exists actual equal paths in the graph, typically in the case of repeats. In order to stick with mathemathical properties, our definition of optimality holds no relation to the origin of a read but is purely defined as the path which produces the highest possible alignment score. As PO-MSA is an exhaustive search we define optimally aligned as alignments which produce the same alignment score as the highest score found by PO-MSA. Consequently, as only the scores are compared, even when the approach produces a different alignment than PO-MSA, this is be classified as optimal behaviour.\\
\par\noindent
\section{Time capturing mechanisms}
For both the "Fuzzy context-based search" and the PO-MSA algorithm the time capturing mechanisms are built into the tool, using the Java System object. This allows us to wrap the time capturing of each individual constituent as close to the functional parts as possible in order to avoid unecessary overhead. When comparing tools the time was taken from the tool was started until the tool ended. Doing it this way has several disadvantages, which are discussed in Section \ref{sec:comparison_tools}. The time unit used throughout the chapter is milliseconds.
\section{Building the index}
The building of the index is the first step of the process realized through the build\_index.sh script. To summarize this step consists of reading the input files, building the graph and generating the suffix trees. The build process was run 50 times on 6 different data sets, the averaged results can be seen in figure \ref{fig:build_index}. All of these are linear operations which is clearly visible.\\

\begin{figure}[!ht]
    \begin{tikzpicture}
      \begin{axis}[scale only axis,height=0.4\textwidth,width=0.4\textwidth,xmin=0,ymin=0,xmax=144480,ymax=125000,scaled ticks=false, xlabel={Number of vertices}, ylabel={Milliseconds}, max space between ticks=50pt, ylabel near ticks]
        \addplot[color=black,mark=*] coordinates {
          (700,597)
          (3345,2050)
          (21070,13858)
          (35770,25401)
          (101570,77928)
          (144480,122654)
        };
      \end{axis}
    \end{tikzpicture}
    \caption{Runtime for the build index procedure}
    \label{fig:build_index}
\end{figure}
\par\noindent
When splitting up the runtime into the individual constituents an interesting pattern emerges (Fig. \ref{fig:index_constituents}): The main load of the indexation lies in writing to file. The data structure used is a large tree of nested complex structures, which the standard Java serialization does not handle well \textcolor{red}{PROB SHUD REFERENCE SOMETHING. API MAYBE}. Putting effort into improved serialization or reducing the size of the index will thus have a dramatic effect on the time complexity.
\begin{figure}[!t]
  \begin{subfigure}[t]{0.4\textwidth}
    \begin{tikzpicture}[trim axis left]
      \begin{axis}[scale only axis,height=\textwidth,width=\textwidth,xmin=0,ymin=0,xmax=144480,ymax=125000,scaled ticks=false]
        \addplot coordinates {
          (700,9)
          (3345,51)
          (21070,623)
          (35770,1031)
          (101570,5487)
          (144480,11328)
        };
      \end{axis}
    \end{tikzpicture}
    \subcaption{Time used building the graph}
  \end{subfigure}
  \hfill
  \begin{subfigure}[t]{0.4\textwidth}
    \begin{tikzpicture}[trim axis left]
      \begin{axis}[scale only axis,height=\textwidth,width=\textwidth,xmin=0,ymin=0,xmax=144480,ymax=125000,scaled ticks=false]
        \addplot[color=green,mark=*] coordinates {
          (701,65)
          (3416,138)
          (21070,269)
          (35770,2788)
          (101570,6905)
          (144480,10007)
        };
      \end{axis}
    \end{tikzpicture}
    \subcaption{Time used building the index}
  \end{subfigure}
  \begin{subfigure}[b]{0.4\textwidth}
    \begin{tikzpicture}[trim axis left]
      \begin{axis}[scale only axis,height=\textwidth,width=\textwidth,xmin=0,ymin=0,xmax=144480,ymax=125000,scaled ticks=false]
        \addplot[color=red,mark=*] coordinates {
          (700,522)
          (3345,1860)
          (21070,1296)
          (35770,21581)
          (101570,65535)
          (144480,101317)
        };
      \end{axis}
    \end{tikzpicture}
    \subcaption{Time used writing the index\vspace{\baselineskip}}
  \end{subfigure}
  \hfill
  \begin{subfigure}[b]{0.4\textwidth}
  \begin{tikzpicture}[trim axis left]
    \begin{axis}[scale only axis,height=\textwidth,width=\textwidth,xmin=0,ymin=0,xmax=144480,ymax=125000,scaled ticks=false]
      \addplot[color=blue,name path=graph] coordinates {
        (700,9)
        (3345,51)
        (21070,623)
        (35770,1031)
        (101570,5487)
        (144480,11328)
      };
      \addplot[color=green, name path=index] coordinates {
        (700,9 + 65)
        (3345,51 + 138)
        (21070,623 + 269)
        (35770,1031 + 2788)
        (101570,5487 + 6905)
        (144480,11328 + 10007)
      };
      \addplot[color=black, name path=total,mark=*] coordinates {
        (700,597)
        (3345,2050)
        (21070,13858)
        (35770,25401)
        (101570,77928)
        (144480,122654)
      };
      \addplot[name path=axis] coordinates {
        (0, 0)
        (144480, 0)
      };
      \addplot[red!30] fill between[of=index and total];
      \addplot[green!30] fill between[of=graph and index];
      \addplot[blue!30] fill between[of=graph and axis];
      \addlegendentry{Build graph}
      \addlegendentry{Build index}
      \addlegendentry{Write index}
    \end{axis}
  \end{tikzpicture}
  \subcaption{Total run time as a combination of the individual steps}
  \label{fig:index_constituents_explicit}
  \end{subfigure}
  \caption{Time used by the indexation process as a function of the number of vertices}
  \label{fig:index_constituents}
\end{figure}
\clearpage
\section{Alignment}
The alignment tests are run by the align\_sequence.sh script, both with \texttt{-{}-type=fuzzy} and \texttt{-{}-type=po\_msa} parameters. The section is divided into segments, based on what variable is tuned. As a remainder to the reader, these are the variables which are in play:
\begin{itemize}
  \item $|G|$ is the size of the graph
  \item $\lambda$ is the allowed error margin
  \item $|s|$ is the length of the input sequence
  \item $b$ is the branching factor of the graph
\end{itemize}
Additionally we include one more variable:
\begin{itemize}
  \item $p$ is the amount of noise added to the reads
\end{itemize}
As each of the subsequent sections are concerned with the impact of exactly one of these variables, the ``non-important'' variables are locked to a standard value:
\begin{itemize}
  \item \textbf{$|G|=35.000$} Representing the mid-range of our test-sets.
  \item \textbf{$\lambda=0, p=0.0$} We let alignment back to the origin represent the base case in the study.
  \item \textbf{$|s|=100$} Common read length for the Illumina HiSeq2000 technology.
  \item \textbf{$b=1$} Calculations can be found in section \ref{sec:runtime_complexity}.
\end{itemize}
\subsection*{Runtime as a function of graph size}
We start by comparing the two alignment algorithms on different graph sizes. Figure \ref{fig:runtime_G} shows the averaged results over 50 runs of each algorithm on the smallest 6 datasets. As expected PO-MSA is completely linear with regards to the number of vertices. The fuzzy search is only dependant on graph size for deciding the suffix tree depth, and the very logarithmical relationship looks almost constant in comparison.
\clearpage
\begin{figure}[!ht]
  \begin{tikzpicture}
    \begin{axis}[scale only axis,height=0.5\textwidth,width=0.5\textwidth,xmin=0,ymin=0,xmax=144480,ymax=2000,scaled ticks=false, legend pos=north west, xlabel={$|G|$}, ylabel={Milliseconds}, legend cell align=left, xtick={50000,100000,150000},ylabel near ticks]
      \addplot[color=blue,mark=*] coordinates {
        (700, 24)
        (3345, 28)
        (21070, 31)
        (35770,  30)
        (101570, 32)
        (144480, 33)
      };
      \addplot[color=black,mark=*] coordinates {
        (700, 85)
        (3345, 89)
        (21070, 297)
        (35770, 454)
        (101570, 1193)
        (144480, 1817)
      };
      \addlegendentry{Fuzzy}
      \addlegendentry{PO-MSA}
    \end{axis}
  \end{tikzpicture}
  \caption{Runtime of the alignment process as a function of $|G|$}
  \label{fig:runtime_G}
\end{figure}
\subsection*{Runtime as a function of error margin}
\textcolor{red}{GRAPH HAS VALUES FROM 3345 SIZE}
\begin{figure}[!hb]
  \begin{tikzpicture}
    \begin{axis}[scale only axis,height=0.5\textwidth,width=0.5\textwidth,xmin=0,ymin=0,xmax=5,ymax=4000000000,scaled ticks=false, legend pos=north west, xlabel={$\lambda$}, ylabel={Nanoseconds},xtick={0,1,2,3,4,5}, legend cell align=left]
      \addplot[color=blue,mark=*] coordinates {
        (0, 26977841)
        (1, 120987192)
        (2, 350870315)
        (3, 947601415)
        (4, 1741219879)
        (5, 3496580015)
      };
      \addplot[color=black,mark=*] coordinates {
        (0, 88628194)
        (5, 88628194)
      };
      \addlegendentry{Fuzzy}
      \addlegendentry{PO-MSA}
    \end{axis}
  \end{tikzpicture}
  \caption{Runtime of the alignment process as a function of $\lambda$}
  \label{fig:runtime_lambda}
\end{figure}[ht]
\begin{figure}
  \begin{tikzpicture}
    \begin{axis}[scale only axis,height=0.5\textwidth,width=0.5\textwidth,xmin=0,ymin=0,xmax=5,ymax=35000000000,scaled ticks=false, legend pos=north west, xlabel={$\lambda$}, ylabel={Nanoseconds},xtick={0,1,2,3,4,5}, legend cell align=left]
      \addplot[color=blue,mark=*] coordinates {
        (0, 39421262)
        (1, 207661867)
        (2, 1109580502)
        (3, 4438734683)
        (4, 15048629538)
        (5, 31101186953)
      };
      \addplot[color=green,mark=*] coordinates {
        (0,217309155)
        (1,541668285)
        (2,1327223214)
        (3,3649467422)
        (4,10466121646)
        (5,21725713902)
      };
      \addplot[color=black,mark=*] coordinates {
        (0, 2008561551)
        (5, 2008561551)
      };
      \addlegendentry{Fuzzy}
      \addlegendentry{Fuzzy with parallellization}
      \addlegendentry{PO-MSA}
    \end{axis}
  \end{tikzpicture}
  \caption{Runtime of the alignment process as a function of $\lambda$ with $|G|=150.000$ and \texttt{-{}-parallellization=true}}
  \label{fig:runtime_lambda_parallell}
\end{figure}
\subsection*{Runtime as a function of sequence length}
Regulating sequence length is done by varying the \texttt{-{}-len} parameter sent to the read generator. The values used are approximations towards values found by actual sequencing technologies\cite{comparison_sequencing_systems}, the results can be found in table \ref{tab:runtimes_s}. As expected both algorithms are very linear with respect to read length, the fuzzy search growing seemingly slower than PO-MSA.
\begin{table}
  \begin{tabular}{|l|l|r|r|}
    \hline \textbf{Technology} & \textbf{Read length} & \textbf{PO-MSA time} & \textbf{Fuzzy time} \\ \hline
    HiSeq2000 (min) & 50 & 171961927 & 19347780 \\ \hline
    HiSeq2000 & 90 & 264031377 & 30038511 \\ \hline
    SOLiDv4 & 100 & 294027088 & 36927650 \\ \hline
    Ion PGM & 200 & 676355995 & 59767319 \\ \hline
    Sanger 3730xl (min) & 400 & 1117436847 & 98570092 \\ \hline
    454 GS FLX & 700 & 1600069004 & 167703497 \\ \hline
    Sanger 3730xl (max) & 900 & 2121961653 & 194846761 \\ \hline
  \end{tabular}
  \caption{Running times for different read lengths for the PO-MSA and fuzzy algorithms}
  \label{tab:runtimes_s}
\end{table}
\begin{figure}
  \begin{tikzpicture}
    \begin{axis}[scale only axis,height=\textwidth,width=\textwidth,xmin=0,ymin=0,xmax=900,ymax=2500000000,scaled ticks=false, legend pos=north west, xlabel={$\lambda$}, ylabel={Nanoseconds}, legend cell align=left]
      \addplot[color=blue,mark=*] coordinates {
        (50,19347780)
        (90,30038511)
        (100,36927650)
        (200,59767319)
        (400,98570092)
        (700,167703497)
        (900,194846761)
      };
      \addplot[color=black,mark=*] coordinates {
        (50,171961927)
        (90,264031377)
        (100,294027088)
        (200,676355995)
        (400,1117436847)
        (700,1600069004)
        (900,2121961653)
      };
      \addlegendentry{Fuzzy}
      \addlegendentry{PO-MSA}
    \end{axis}
  \end{tikzpicture}
  \caption{Runtime of the alignment process as a function of $|s|$}
  \label{fig:runtime_s}
\end{figure}
\subsection*{Runtime as a function of graph complexity}
\label{sec:runtime_complexity}
The graph complexity is decided by the number of variants featured in the graph. We have let the branching factor $b$ be our benchmark with regards to the complexity. This section will feature testing on two distinct datasets. A set of real allelles for different genes in the MHC region and a set of generated variation for the 35k.fasta sequence. Both datasets contain what could be considered rather moderate values of $b$, the real life data in particular. This is a reflection of genetic variation. Using the numbers from section \ref{sec:human_genome}, assuming every variant creates a new branch and that every human has a unique set of variants, a reference graph of the entire human genome would have a branching factor of approximately $1 + |p|*0.000007$ where $|p|$ is the population size \textcolor{red}{footnote with values}. This is the reason we often use the approximate value $b=1$. It is important to remember that this number is concerned with branching on a vertex level, the actual number of variants grow exponentially with regards to the graph size.
\begin{figure}
  \begin{tikzpicture}
    \begin{axis}[scale only axis,height=\textwidth,width=\textwidth,xmin=1,ymin=0,xmax=900,ymax=2500000000,xmax=1.2,scaled ticks=false, legend pos=north west, xlabel={$\lambda$}, ylabel={Nanoseconds}, legend cell align=left]
      \addplot[color=blue,mark=*] coordinates {
        (1,30924263)
        (1.009,36332244)
        (1.019,38308170)
        (1.04,37368688)
        (1.07,33923728)
      };
      \addplot[color=green,mark=*] coordinates {
        (1,0)
        (1.009,190239910)
        (1.019,186633216)
        (1.04,220772316)
        (1.07,232592316)
      };
      \addplot[color=purple,mark=*] coordinates {
        (1,0)
        (1.009,1230413913)
        (1.019,1305138234)
        (1.04,1238580349)
        (1.07,1126601179)
      };
      \addplot[color=black,mark=*] coordinates {
        (1,0)
        (1.009,503079694)
        (1.019,500920971)
        (1.04,0)
        (1.07,527164014)
      };
      \addlegendentry{Fuzzy, \texttt{-{}-error-margin=0}}
      \addlegendentry{Fuzzy, \texttt{-{}-error-margin=1}}
      \addlegendentry{Fuzzy, \texttt{-{}-error-margin=2}}
      \addlegendentry{PO-MSA}
    \end{axis}
  \end{tikzpicture}
  \caption{Runtime of the alignment process as a function of $b$}
  \label{fig:runtime_b}
\end{figure}
\subsection*{Correctness as a function of noise}
\begin{wraptable}{r}{0.3\textwidth}
  \begin{tabular}{|c|c|}
    \hline $p$ & \textbf{Correctness} \\ \hline
    0.00 & 100\% \\ \hline
    0.01 & 93\% \\ \hline
    0.02 & 73\% \\ \hline
    0.04 & 44\% \\ \hline
    0.06 & 36\% \\ \hline
    0.08 & 12\% \\ \hline
    0.1 & 8\% \\ \hline
  \end{tabular}
  \caption{Percentage of correctly aligned reads as $p$ varies and $\lambda$ is fixed}
  \label{tab:correctness}
\end{wraptable}
\begin{figure}
  \begin{center}
    \begin{tikzpicture}[every node/.style={anchor=base,text depth=.5ex,text height=2em,text width=2em},align=center,text centered]
      \matrix(A) [nodes={rectangle}] {
        \node {5}; & \HeatmapNode{100} & \HeatmapNode{100} & \HeatmapNode{99} & \HeatmapNode{96} & \HeatmapNode{83} & \HeatmapNode{80} \\
        \node {4}; & \HeatmapNode{100} & \HeatmapNode{99} & \HeatmapNode{96} & \HeatmapNode{83} & \HeatmapNode{73} & \HeatmapNode{61} \\
        \node {3}; & \HeatmapNode{100} & \HeatmapNode{97} & \HeatmapNode{87} & \HeatmapNode{76} & \HeatmapNode{52} & \HeatmapNode{45} \\
        \node {2}; & \HeatmapNode{100} & \HeatmapNode{93} & \HeatmapNode{73} & \HeatmapNode{59} & \HeatmapNode{44} & \HeatmapNode{41} \\
        \node {1}; & \HeatmapNode{100} & \HeatmapNode{84} & \HeatmapNode{55} & \HeatmapNode{38} & \HeatmapNode{36} & \HeatmapNode{25} \\
        \node {0}; & \HeatmapNode{100} & \HeatmapNode{79} & \HeatmapNode{38} & \HeatmapNode{18} & \HeatmapNode{10} & \HeatmapNode{4} \\
        \node {};  & \node{0}; & \node{0.01}; & \node{0.02}; & \node{0.03}; & \node{0.04}; & \node{0.05}; \\
      };
      \node[draw=none] at (0.5, -0.75) {$p$};
      \node[draw=none] at (-4, 3.85) {$\lambda$};
    \end{tikzpicture}
  \end{center}
  \caption{Percentage of correctly aligned reads as a function of both $p$ and $\lambda$ varies}
  \label{fig:correctness_both}
\end{figure}
\section{Comparison with other tools}
\label{sec:comparison_tools}
\begin{figure}
  \begin{tikzpicture}[trim axis left]
    \begin{axis}[scale only axis,height=\textwidth,width=\textwidth,xmin=140,ymin=0,xmax=7000,ymax=2563031551,scaled ticks=false,xtick={140,1000,3000,5000,7000}, legend pos=north west]
      \addplot[color=blue,mark=*, name path=index] coordinates {
      	(140,4489488+11282628)
        (700,8135746+22973337)
        (2000,20029169+57785340)
        (3345,29047859+61984755)
        (7000,64993790+81623625)
      };
      \addplot[color=red, name path=total,mark=*] coordinates {
      	(140,515689436)
        (700,559241699)
        (2000,1128971607)
        (3345,1408628008)
        (7000,2563031551)
      };
      \addplot[color=black, name path=vg,mark=*] coordinates {
      	(140,1087249638)
      	(700,1084725831)
      	(2000,1091623191)
        (3345,1093076902)
        (7000,1125346207)
      };
      \addplot[name path=axis] coordinates {
        (0, 0)
        (7000, 0)
      };
      \addplot[red!30] fill between[of=index and total];
      \addplot[blue!30] fill between[of=axis and index];
      \addlegendentry{Fuzzy algorithm time}
      \addlegendentry{Fuzzy tool time}
      \addlegendentry{Sequence graphs tool time}
    \end{axis}
  \end{tikzpicture}
  \caption{Time spent building the index by the different tools}
  \label{fig:comparison_build}
\end{figure}
\begin{figure}
  \begin{tikzpicture}[trim axis left]
    \begin{axis}[scale only axis,height=\textwidth,width=\textwidth,xmin=140,ymin=0,xmax=7000,ymax=2241645198,scaled ticks=false,xtick={140,1000,3000,5000,7000}, legend pos=north west]
      \addplot[color=blue,mark=*, name path=index] coordinates {
      	(140,28018035)
        (700,28893900)
        (2000,29239255+5000000)
        (3345,28611678)
        (7000,31094903)
      };
      \addplot[color=red, name path=total,mark=*] coordinates {
      	(140,364716528)
        (700,539453102)
        (2000,948561937)
        (3345,1272551796)
        (7000,2241645198)
      };
      \addplot[color=black, name path=vg,mark=*] coordinates {
      	(104,1015797972)
      	(700,1018260083)
      	(2000,1022342313)
        (3345,1024211899)
        (7000,1032607478)
      };
      \addplot[name path=axis] coordinates {
        (0, 0)
        (7000, 0)
      };
      \addplot[red!30] fill between[of=index and total];
      \addplot[blue!30] fill between[of=axis and index];
      \addlegendentry{Fuzzy algorithm time}
      \addlegendentry{Fuzzy tool time}
      \addlegendentry{Sequence graphs tool time}
    \end{axis}
  \end{tikzpicture}
  \caption{Runtimes of the two tools}
  \label{fig:comparison_align}
\end{figure}
\begin{figure}
  \begin{tikzpicture}[trim axis left]
    \begin{axis}[scale only axis,height=\textwidth,width=\textwidth,xmin=0,ymin=0,xmax=0.05,ymax=100,scaled ticks=false, legend pos=north east,xtick={0,0.01,0.02,0.03,0.04,0.05}]
      \addplot[color=blue] coordinates {
        (0, 100-0)
        (0.01,100-7)
        (0.02,100-30)
        (0.03,100-42)
        (0.04,100-68)
        (0.05,100-78)
      };
      \addplot[color=black] coordinates {
        (0, 100-0)
        (0.01,100-50)
        (0.02,100-78)
        (0.03,100-98)
        (0.04,100-98)
        (0.05,100-100)
      };
      \addlegendentry{Fuzzy search}
      \addlegendentry{Sequence graphs}
    \end{axis}
  \end{tikzpicture}
  \caption{Correctly mapped reads from the two tools with $\lambda=2$}
  \label{fig:comparison_correctness}
\end{figure}
\end{document}