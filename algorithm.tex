\documentclass{article}

\begin{document}
\chapter{Design}
In this section we will present the algorithm ``Fuzzy context-based search'' as an approach for aligning text strings against graph-based reference genomes. First the remaining elements involved in precisely defining the problem will be described. Then the syntax of the reference graphs used are explained in more detail. Finally, the algorithm is presented both through a conceptual overview and in specific detail. The implementation details refers to the tool \textit{Graph Genome Alignment} (See Supplementary XXX).
\section{Definitions}
\begin{defn}[Incomplete path]
  An ordered list $L$ of indexes such that for all consecutive ordered pairs $\{i_x, i_{x+1}\} \in L$ there exists a path $P$ which starts at $\{i_x\}$ and ends at $i_{x+1}\}$.
\end{defn}
\begin{defn}[Input sequence]
  A string $s$ over the alphabet $\{A, C, T, G\}$. The length of the string is given by $|s|$. An individual character on position $x$ is referenced by $s_x$
\end{defn}
\begin{defn}[Path score]
  A score produced by traversing an incomplete path $P$ through a graph $G$ to create a linear sequence, scoring gaps according to the gap penalties given by a scoring schema.
\end{defn}
\begin{defn}[Alignment]
  Given a sequence $s$ and a graph $G$, an ordered list $A$ of indexes such that every $a_x \in A$ is either a valid index for a vertice in $G$ or $0$. $0$ indicates an unmapped element of the input sequence
\end{defn}
\begin{defn}[Alignment score]
  Given a sequence $s$, a graph $G$ and an alignment $A$, the score produced by combining mapping scores for the pairs $\{a_x, s_x\} for 0<=x<|s|$ with the path score for the incomplete path(s) provided by $A$ aligned against both $G$ and $s$.
\end{defn}
\begin{defn}[The optimal alignment score problem]
  For any pair $\{G, s\}$, where $G$ is a graph and $s$ is a sequence, find the alignment $A$ which produces the highest possible alignment score.
  \textcolor{red}{If multiple max scores: Provide all or chose one?}
\end{defn}
\begin{defn}[The bounded optimal alignment score problem]
  Given a triplet $\{G, s, T\}$ where $G$ and $s$ are as before and $T$ is a numeric value, find the alignment $A$ which produces the highest alignment score, iff alignment the score for $A$ is higher than $T$. If no such alignment exists, $s$ is unalignable.
\end{defn}
\section{The graph}
As defined the graphs involved will be graphs where one vertice represents a single nucleotide. Every vertice also contains an identifying index, which maps uniquely to that vertice. A graph $G$ is made by starting out with only the start and end vertices, and iteratively merging in new sequences. Every sequence merged into the graph has a corresponding path starting in $s_G$ and ending in $t_G$ called a \textit{full path}. 
\begin{defn}[Full path]
  A path $p$ through a graph where the first element is $s_G$ and the last element is $t_G$
\end{defn}
\noindent
There is no correspondence the other way, meaning there can be paths from $s_G$ to $t_G$ which does not originate from a single sequence (Fig. \ref{fig:example_reference}). There exists no information storing the origin of an edge and all paths are thus seen as equally probable when aligning a sequence. How the new sequences are merged is defined entirely through the alignment procedure which relies in part on the scoring threshold $\lambda$ and the given scoring schema.
\clearpage
\begin{figure}
  \begin{mdframed}
    \begin{center}
      \begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=1.4cm,scale=0.5]
        \node[state,align=center] (q0) {$s$\\ \scriptsize{0}};
        \node[state,align=center] [right of=q0] (q1) {$A$\\ \scriptsize{1}};
        \node[state,align=center] [above right=0.6cm and 0.63cm of q1] (q2) {$T$\\ \scriptsize{2}};
        \node[state,align=center] [right of=q1] (q3) {$G$\\ \scriptsize{6}};
        \node[state,align=center] [below right=0.6cm and 0.63cm of q1] (q4) {$C$\\ \scriptsize{8}};
        \node[state,align=center] [right of=q3] (q5) {$A$\\ \scriptsize{3}};
        \node[state,align=center] [above right of=q5] (q6) {$T$\\ \scriptsize{4}};
        \node[state,align=center] [below right of=q5] (q7) {$G$\\ \scriptsize{7}};
        \node[state,align=center] [below right of=q6] (q8) {$A$\\ \scriptsize{5}};
        \node[state,align=center] [right of=q8] (q9) {$e$\\ \scriptsize{-1}};

        \path
        (q0) edge node {} (q1)
        (q1) edge node {} (q2)
        edge node {} (q3)
        edge node {} (q4)
        (q2) edge node {} (q5)
        (q3) edge node {} (q5)
        (q4) edge node {} (q5)
        (q5) edge node {} (q6)
        edge node {} (q7)
        edge node {} (q8)
        (q6) edge node {} (q8)
        (q7) edge node {} (q8)
        (q8) edge node {} (q9);
      \end{tikzpicture}
    \end{center}
  \end{mdframed}
  \caption{A graph $G$ made from the three sequences ``ATATA'', ``AGAGA'' and ``ACAA'' with 9 valid paths from $s_G$Â to $t_G$}
  \label{fig:example_reference}
\end{figure}
\section{Aligning sequences}
\subsection{Overview}
``Fuzzy context-based search'' is the algorithm we propose as a solution to the bounded optimal alignment score problem. The first step of the process is to build a searchable index based on the given graph $G$. This index is independent from the input sequences to be aligned, and can thus be reused for several searches. The alignment itself consists of two steps: Building a new graph $G'$, from both $G$ and an input string $s$, and search this newly formed graph for the optimal alignment. Searching for an alignment means combining nodes, representing bases, into a path which represents a linear sequence. This linear sequence can be aligned against the input sequence with regular string alignment tools and is therefore easily scorable. If the algorithm finds an alignment this is guaranteed to be one of the paths which produces the highest possible alignment score for any path in the graph (See supplementary XXX \textcolor{red}{PROOF}). There are some situations where the algorithm results in an empty alignment. These cases will occur when there are no paths in the graph which produces an alignment score higher than the defined threshold $T$, and the sequence $s$ is identified as unalignable. When an empty alignment is provided as a basis for merging a new sequence into the graph, this results in a new full path which is separated from the original vertices (Fig. \ref{fig:separate_paths})
\subsection{Building the index}
There are two data structures needed for aligning a string against the graph: a suffix tree for left contexts and a suffix tree for right contexts. Before either of the two are built the algorithm needs to decide a length for the contexts. Currently in the tool there are two ways of setting the context length: A user given parameter or an approximation based on the probability of sharing contexts \textcolor{red}{Should probably ref somewhere}. The length of the contexts does not impact the quality of the alignments found by the algorithm (See Supplementary XXX \textcolor{red}{PROOF}) but will have an impact on the runtime (See Supplementary XXX \textcolor{red}{COMPLEXITY ANALYSIS}).\\
\par\noindent
\begin{wrapfigure}{r}{0.5\textwidth}
  \begin{mdframed}
    \begin{subfigure}[t]{\textwidth}
      \begin{mdframed}
        \begin{center}
          \begin{tabularx}{\linewidth}{ccccc}
            & T & C & A & G \\ \cline{2-5}
            T & \multicolumn{1}{|c|}{0} & -1 & \multicolumn{1}{|c|}{-2} & \multicolumn{1}{c|}{-3} \\ \cline{2-5}
            C & \multicolumn{1}{|c|}{-1} & 0 & \multicolumn{1}{|c|}{-1} & \multicolumn{1}{c|}{-2} \\ \cline{2-5}
            C & \multicolumn{1}{|c|}{-2} & -1 & \multicolumn{1}{|c|}{-1} & \multicolumn{1}{c|}{-2} \\ \cline{2-5}
            G & \multicolumn{1}{|c|}{-3} & -2 & \multicolumn{1}{|c|}{-2} & \multicolumn{1}{c|}{-1} \\ \cline{2-5}
          \end{tabularx}
        \end{center}
      \end{mdframed}
      \caption{The dynamic programming table for aligning the two strings ``TCAG'' and ``TCCG'' using edit distance as a scoring schema}
    \end{subfigure}
    \begin{subfigure}[t]{\textwidth}
      \begin{mdframed}
        \begin{center}
          \begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=1.3cm]
            \node[state,scale=0.7] (q0) {$s$};
            \node[state,scale=0.7] [above right of=q0] (q1) {$T$};
            \node[state,scale=0.7] [right of=q1] (q2) {$C$};
            \node[state,scale=0.7] [right of=q2] (q3) {$A$};
            \node[state,scale=0.7] [right of=q3] (q4) {$G$};
            \node[state,scale=0.7] [below right of=q0] (q5) {$T$};
            \node[state,scale=0.7] [right of=q5] (q6) {$C$};
            \node[state,scale=0.7] [right of=q6] (q7) {$C$};
            \node[state,scale=0.7] [right of=q7] (q8) {$G$};
            \node[state,scale=0.7] [above right of=q8] (q9) {$e$};

            \path
            (q0) edge node {} (q1)
            edge node {} (q5)
            (q1) edge node {} (q2)
            (q2) edge node {} (q3)
            (q3) edge node {} (q4)
            (q4) edge node {} (q9)
            (q5) edge node {} (q6)
            (q6) edge node {} (q7)
            (q7) edge node {} (q8)
            (q8) edge node {} (q9);
          \end{tikzpicture}
        \end{center}
      \end{mdframed}
      \caption{The result of aligning and merging the sequences with $T=0$}
    \end{subfigure}
    \begin{subfigure}[t]{\textwidth}
      \begin{mdframed}
        \begin{center}
          \begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=1.3cm]
            \node[state,scale=0.7] (q0) {$s$};
            \node[state,scale=0.7] [right of=q0] (q1) {$T$};
            \node[state,scale=0.7] [right of=q1] (q2) {$C$};
            \node[state,scale=0.7] [above right of=q2] (q3) {$A$};
            \node[state,scale=0.7] [below right of=q2] (q4) {$C$};
            \node[state,scale=0.7] [below right of=q3] (q5) {$G$};
            \node[state,scale=0.7] [right of=q5] (q6) {$e$};

            \path
            (q0) edge node {} (q1)
            (q1) edge node {} (q2)
            (q2) edge node {} (q3)
            edge node {} (q4)
            (q3) edge node {} (q5)
            (q4) edge node {} (q5)
            (q5) edge node {} (q6);
          \end{tikzpicture}
        \end{center}
      \end{mdframed}
      \caption{The result of aligning and merging the sequences with $T=-1$}
    \end{subfigure}
  \end{mdframed}
  \caption{Different scoring thresholds $T$ yields different reference graphs}
  \label{fig:separate_paths}
\end{wrapfigure}
When a context length $|c|$ is set, the algorithm can start building the index. Two sets of strings, a left context set and a right context set, is generated for every vertice in the graph $G$. The generation of the two sets happen by the same procedure by swapping around the starting point and the direction of the iteration. When creating left contexts the algorithm starts in the start-node of $G$ and traverses following the direction of the edges, for right contexts the opposite is done. Apart from this the two are equal. To generate the context set $c(n_x)$ for a given node $n_x$ the algorithm looks at every string $c \in c(n_y)$ for every incoming neighbouring node $n_y$. Every $c$ is modified into a new context string $c'$ by trimming away the last character and prefixing the context with the character $b(n_y)$. All the generated strings $c'$ is added to $c(n_x)$. As sets per definition does not allow duplicates the impact of a branching occuring in the graph will fade away after exactly $|c|$ steps as the difference is trimmed away (see Fig. \ref{fig:explicit_contexts}), and thus avoid explosive exponentiality in the context set sizes. Unlike Paten et al. \cite{mapping_to_a_reference_genome_structure} there are no requirements for contexts to be uniquely mappable to exactly one vertice. Because the last step of the algorithm does a search for an incomplete path through all the found vertices this presents no difficulties when finding the alignment. Furthermore, dropping this precondition assures every node has two valid contexts and are thus present in both suffix trees.\\
\par\noindent
The iteration starts in the node defined as the starting point which has the empty string $\epsilon$ as its only context. Whenever a node has finished producing its contexts it enqueues everyone of its outgoing neighbours in a regular FIFO queue. If a vertice has more actual incoming neighbours than incoming neighbours which are finished generating contexts, the node puts itself back in the queue. Thus happens to ensure that when a vertice is finished generating context, both the vertice itself and all preceding vertices are finished, and the remaining nodes can safely fetch contexts from its neighbours. The algorithm halts when the queue is empty. Every node has to be visited exactly once to generate its context, looking up its approximately $b$ neighbours, and as the procedure runs twice to generate both sets the total runtime for the operation is $O(2|G|b)$.\\
\begin{figure}[t!]
  \begin{center}
    \begin{mdframed}
      \begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=3.5cm]
        \node[state,align=center,minimum size=3cm,scale=0.75] (q0) {\footnotesize{\{"$G$", "$T$"\}}\\\Large{\textbf{$A$}}\\\footnotesize{\{"$TA$"\}}\\\scriptsize{$2$}};
        \node[state,align=center,minimum size=3cm,scale=0.75] [below left of=q0] (q1) {\footnotesize{$\{\epsilon\}$}\\$G$\\\footnotesize{\{"$AT$"\}}\\\scriptsize{$6$}};
        \node[state,align=center,minimum size=3cm,scale=0.75] [above left of=q0] (q2) {\footnotesize{$\{\epsilon\}$}\\$T$\\\footnotesize{\{"$AT$"\}}\\\scriptsize{$1$}};
        \node[state,align=center,minimum size=3cm,scale=0.75] [right of=q0] (q3) {\\\footnotesize{\{"$AG$", "$AT$"\}}\\$T$\\\footnotesize{\{"$AG$"\}}\\\scriptsize{$3$}};
        \node[state,align=center,minimum size=3cm,scale=0.75] [right of=q3] (q4) {\footnotesize{\{"$TA$"\}}\\$A$\\\footnotesize{\{"$G$"\}}\\\scriptsize{$4$}};
        \node[state,align=center,minimum size=3cm,scale=0.75] [right of=q4] (q5) {\footnotesize{\{"$AT$"\}}\\$G$\\\footnotesize{$\{\epsilon\}$}\\\scriptsize{$5$}};

        \path
        (q1) edge node {} (q0)
        (q2) edge node {} (q0)
        (q0) edge node {} (q3)
        (q3) edge node {} (q4)
        (q4) edge node {} (q5);

      \end{tikzpicture}
    \end{mdframed}
  \end{center}
  \caption{A small reference graph with left contexts (top) and right contexts (bottom) of length 2 shown}
  \label{fig:explicit_contexts}
\end{figure}
\par\noindent
After generating the two context sets for every node, the elements of each one is inserted into their corresponding suffix tree. Every suffix is stored as a key with the index of it's originating node as a value (fig. \ref{fig:left_suffix_tree}). In theory every node can have $4^{|c|}$ contexts in each set, in practice a more fair approximation is $b^{|c|}$ where $b$ is the observed branching factor for the graph. \textcolor{red}{Should contain something about probable values of B. Find an article on it}. 
\begin{wrapfigure}{R}{0.49\textwidth}
  \begin{mdframed}
    \begin{tikzpicture}
      \node[state,align=center,minimum size=1.4cm] (q0) {$\epsilon$\\\scriptsize{\{$1,6$\}}};
      \node[state,align=center,minimum size=1.4cm] [below left=0.6cm and 0.6cm of q0] (q1) {$A$\\\scriptsize{$\emptyset$}};
      \node[state,align=center,minimum size=1.4cm] [below=0.21cm of q0] (q2) {$G$\\\scriptsize{\{$2$\}}};
      \node[state,align=center,minimum size=1.4cm] [below right=0.6cm and 0.6cm of q0] (q3) {$T$\\\scriptsize{\{$2$\}}};
      \node[state,align=center,minimum size=1.4cm] [below left=0.6cm and 0cm of q1] (q4) {$G$\\\scriptsize{\{$3$\}}};
      \node[state,align=center,minimum size=1.4cm] [below right=0.6cm and 0cm of q1] (q5) {$T$\\\scriptsize{\{$3,5$\}}};
      \node[state,align=center,minimum size=1.4cm] [below=0.2cm of q3] (q6) {$A$\\\scriptsize{\{$4$\}}};

      \path
      (q0) edge node {} (q1)
      edge node {} (q2)
      edge node {} (q3)
      (q1) edge node {} (q4)
      edge node {} (q5)
      (q3) edge node {} (q6);
    \end{tikzpicture}
  \end{mdframed}
  \caption{The left suffix tree corresponding to the graph in \ref{fig:explicit_contexts}}
  \label{fig:left_suffix_tree}
\end{wrapfigure}
The current implementation uses a naive suffix tree implementation where insertion is $O(|c|)$ \textcolor{red}{(Discuss more efficient suffix possibilities somewhere?)}, giving a total time complexity of $O(b^{|c|}|c|)$ per node per context set and $O(2|G|b^{|c|}|c|)$ for the entire graph. Building the entire index can thus be done in $O(2|G| + 2|G|b^{|c|}|c|)$.
\subsection{Generating the modified graph}
The motivation behind building an entirely new graph is the realization that whenever reads are mapped against a reference genome the read is typically vastly shorter than the reference. We can therefore do a \textit{linear pruning} where we determine which parts along the direction are interesting for the alignment. The same argument can be made for extremely complex graphs, where only a small number of the branches are relevant, in a process which can be seen as a \textit{vertical pruning}. The result of both kinds of pruning is a graph consisting of \textit{candidate vertices} which is far smaller in size compared to the original graph.\\
\par\noindent
Creating $G'$ is the process of determining which vertices qualifies as candidate vertices for a given input string $s$ and how they should be connected. In order to determine actual candidates for the given string, the algorithm needs to know how much \textit{fuzzyness} to allow. This is a measure which decides how different a read can be from its optimal counterpart in the graph before it is categorized as not mappable. The algorithm takes in a fuzzyness parameter $\lambda$ which can be used to set a threshold $T=maxScore(x)-\lambda$. The maximal score is found by mapping the string $x$, be it the entire input string or a context string, against itself with the scoring function provided by the scoring schema. Both $\lambda$ and $T$ is used throughout the entire process as cutoff variables. Whether $T$ is a threshold for the entire string, for a path or for a substring is either explicitly defined or unambiguous in the given context frame.\\
\par\noindent
After generating the two context sets for every node, the elements of each one is inserted into their corresponding suffix tree. In theory every node can have $4^{|c|}$ contexts in each set. When the graph is more or less linear with few branches a more fair approximation is $B*|c|$ where $B$ is the observed branching factor. The current implementation in the tool uses a naive suffix tree where insertion is $O(|c|)$. This is done for every node in the graph, yielding a total time complexity of $O(|G|B|c|^2)$. A discussion on more efficient suffix structures can be found in \textcolor{red}{SOMEWHERE IN DISCUSSION}. Every suffix is stored as a key with the index of it's originating node as a value. The total runtime for building a searchable index for a graph is $O(3|G||c|^2B)$
\par\noindent
For every character $s_x \in s$ a left-context string and a right-context string is generated by looking at the $|c| + maxPossibleGapGivenFuzzyness(\lambda)$ surrounding characters. The two strings are treated as contexts, one left and one right, and used as a basis for a fuzzy search in it's corresponding suffix tree. The search is a recursive function based on PO-MSA. The root node is supplied with a one-dimensional scoring array corresponding to the context string $c$, which is initialized with all zeroes. Then, for every child, a new scoring array is computed by regular edit distance rules: For each index $i$ take the maximal score for either a gap in the graph, a gap in the string or matching the character $c_i$ with the character contained in the child node \textcolor{red}{(Reference actual code in supplementary?), (more explanation needed?)}. This newly created array is supplemented to the same recursive function in the child. When a leaf node is reached the last index of the supplied scoring array corresponds to mapping the entire string $c$ against the entire context achieved by concatenating the characters contained in the path through the tree traversed by the recursion. If the score is higher than the threshold $T$ for the given context string, every index contained in the node is stored as a pair on the form $\{index, score\}$ in the candidate set. If an index is stored several times, only the pair containing the highest score is saved.\\
\par\noindent
\par
In theory every leaf node has to be visited in order to check the score for every represented context in the tree. In practice the tree can be pruned by cutting off the search whenever the \textit{maximal potential score} falls below the threshold $T$ for the provided context. The maximal potential score for a node is found by adding together the currently highest score in the scoring array with the maximal matching score for the remainder of the string. This reduces the number of nodes to be searched from $O(4^c)$ to \textcolor{red}{(something alot smaller. Needs calculations)}.\\
\clearpage
\begin{wrapfigure}{L}{0.5\textwidth} 
  \begin{subfigure}[t]{\textwidth}
    \begin{mdframed}
      \begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=3.5cm]
        \node[state,draw=none,align=center] (q0) {$A$\\\scriptsize{LC=$\epsilon$}\\\scriptsize{RC="$TA$"}};
        \node[state,draw=none,align=center] [right=-0.15cm of q0] (q1) {$T$\\\scriptsize{LC="$A$""}\\\scriptsize{RC="$A$"}};
        \node[state,draw=none,align=center] [right=-0.15cm of q1] (q2) {$A$\\\scriptsize{LC="$TA$""}\\\scriptsize{RC=$\epsilon$}};

        \node[state,align=center] [below=0cm of q0] (q3) {$A$\\\scriptsize{$2$}};
        \node[state,align=center] [below=0cm of q1] (q4) {$T$\\\scriptsize{$3$}};
        \node[state,align=center] [below=0cm of q2] (q5) {$A$\\\scriptsize{$4$}};
      \end{tikzpicture}
    \end{mdframed}
    \caption{$T=0$}
  \end{subfigure}	
  \begin{subfigure}[t]{\textwidth}
    \begin{mdframed}
      \begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=3.5cm,scale=0.6]
        \node[state,draw=none,align=center] (q0) {$A$\\\scriptsize{LC=$\epsilon$}\\\scriptsize{RC="$TA$"}};
        \node[state,draw=none,align=center] [right=-0.15cm of q0] (q1) {$T$\\\scriptsize{LC="$A$""}\\\scriptsize{RC="$A$"}};
        \node[state,draw=none,align=center] [right=-0.15cm of q1] (q2) {$A$\\\scriptsize{LC="$TA$""}\\\scriptsize{RC=$\epsilon$}};

        \node[state,align=center] [below=-0.04cm of q0] (q3) {$T$\\\scriptsize{$1$}};
        \node[state,align=center] [below=0.3cm of q3] (q4) {$A$\\\scriptsize{$2$}};
        \node[state,align=center] [below=0.3cm of q4] (q5) {$T$\\\scriptsize{$3$}};
        \node[state,align=center] [below=0.3cm of q5] (q6) {$G$\\\scriptsize{$6$}};

        \node[state,align=center] [below=0cm of q1] (q7) {$T$\\\scriptsize{$1$}};
        \node[state,align=center] [below=0.3cm of q7] (q9) {$T$\\\scriptsize{$3$}};
        \node[state,align=center] [below=0.3cm of q9] (q11) {$G$\\\scriptsize{$5$}};
        \node[state,align=center] [below=0.3cm of q11] (q12) {$G$\\\scriptsize{$6$}};

        \node[state,align=center] [below=-0.07cm of q2] (q13) {$T$\\\scriptsize{$3$}};
        \node[state,align=center] [below=0.3cm of q13] (q14) {$A$\\\scriptsize{$4$}};
        \node[state,align=center] [below=0.3cm of q14] (q15) {$G$\\\scriptsize{$5$}};
      \end{tikzpicture}
    \end{mdframed}
    \caption{$T=1$}
  \end{subfigure}
  \caption{The resulting candidate sets for mapping the string "ATA" against the reference genome from fig. ~\ref{fig:explicit_contexts} with varying T values}
  \label{fig:candidate_nodes}
\end{wrapfigure}
After the fuzzy search is concluded there are two sets of candidates for every index, one containing the nodes matching the left context and an equivalent for nodes matching the right context. These two sets are intersected to produce a final candidate set for the index $i$, where the score is created by adding together the scores from the two original sets. When the intersection happens the final set can again be pruned by removing all vertices which has a combined score that is lower than the combined threshold $T$ for both contexts. When the vertices are found the edges need to be generated in order to finish the graph. Intuitively there should be an edge whereever there is a gap which is traversable without having the gap penalty exceeding $\lambda$. In practice this is a step which is done during the next step of the algorithm.\\
\par\noindent
The newly formed graph $G'$ can be defined formally:\\
\par
$G'(G, s, T) = \{V', E'\}$\\
\par\noindent
where $V'$ is an ordered set of sets of length $|s|$ where each set $V'_i$ is a set of nodes such that\\
\par
$V'_i=\{v_x|v_x \in G \land \exists [c \in c(v_x)](alignmentScore(c, c(s_i)) >= T)\}$\\
\par\noindent
and $E'$ is a list of weighted edges such that\\
\par
$E'=\{e'=\{i_s, i_e, w\}|v_{i_s} \in V'_x \wedge v_{i_e} \in V'_y \wedge$ $gapPenalty(y - x) <= \lambda \wedge $\par$w=distance(v_{i_s}, v_{i_e}) \wedge gapPenalty(w) <= \lambda\}$\\
\par\noindent
where $alignmentScore(x, y)$ and $gapPenalty(x, y)$ are scoring functions provided by the scoring schema and $distance(x, y)$ is the distance of the shortest path from node $x$ to node $y$ in the graph. \textcolor{red}{(Mixing up nodes and indexes in the definitions)}\\
\par\noindent
\subsection{Searching G' with a modified PO-MSA search}
When the candidate nodes for each position has been chosen the next step is to find out how they can be combined into a single linear path. This is equivalent to finding the path through $G'$ which traversal gives the best score within the given scoring schema. Conceptually this is in many ways similar to a regular PO-MSA search. The difference is that the roles are switched: Instead of searching through the reference graph with an input string we are searching through the indices of the string with the canditate nodes from the reference graph as our input. Instead of giving every node a score for every index in the string we give every index of the string a score for every candidate node. These scores are found through dynamic programming by filling out an array $scores$ which has the same dimensions as the structure storing the candidate node sets. Because sets are not indexable, the indexes of the candidate nodes are also stored in an integer array $indexes$ such that $indexes[i][j]$ references the index for the $j$-th candidate node in the set $V'_i$  and $scores[i][j]$ references the score for mapping the substring $s'$ of $s$ spanning the indexes 0 to $i$ to the a path ending in the node with index $indexes[i][j]$. In order to store the actual path yielding the score a third array of pairs, $backpointers$, of the same dimensions, is also needed.\\
\par\noindent
\begin{wrapfigure}{l}{0.5\textwidth}
  \begin{mdframed}
    \begin{subfigure}[t]{0.49\textwidth}
      \begin{center}
        \begin{tabularx}{\textwidth}{ccc}
          A & T & A \\ \cline{1-3}
          \multicolumn{1}{|c|}{1} & 1 & \multicolumn{1}{|c|}{3} \\ \cline{1-3}
          \multicolumn{1}{|c|}{2} & 3 & \multicolumn{1}{|c|}{4} \\ \cline{1-3}
          \multicolumn{1}{|c|}{3} & 5 & \multicolumn{1}{|c|}{5} \\ \cline{1-3}
          \multicolumn{1}{|c|}{6} & 6 & \multicolumn{1}{|c}{ }  \\ \cline{1-2}
        \end{tabularx}
        \caption{Indexes}
      \end{center}
    \end{subfigure}
    \begin{subfigure}[t]{0.49\textwidth}
      \begin{center}
        \begin{tabularx}{\textwidth}{ccc}
          A & T & A \\ \cline{1-3}
          \multicolumn{1}{|c|}{-1} & -2 & \multicolumn{1}{|c|}{-2} \\ \cline{1-3}
          \multicolumn{1}{|c|}{0} & 0 & \multicolumn{1}{|c|}{0} \\ \cline{1-3}
          \multicolumn{1}{|c|}{-1} & -3 & \multicolumn{1}{|c|}{-2} \\ \cline{1-3}
          \multicolumn{1}{|c|}{-1} & -3 & \multicolumn{1}{|c}{ }  \\ \cline{1-2}
        \end{tabularx}
        \caption{Scores}
      \end{center}
    \end{subfigure}
    \begin{subfigure}[b]{\textwidth}
      \begin{center}
        \begin{tabularx}{\textwidth}{ccc}
          A & T & A \\ \cline{1-3}
          \multicolumn{1}{|c|}{-1:-1} & 0:0 & \multicolumn{1}{|c|}{1:1} \\ \cline{1-3}
          \multicolumn{1}{|c|}{-1:-1} & 0:1 & \multicolumn{1}{|c|}{1:1} \\ \cline{1-3}
          \multicolumn{1}{|c|}{-1:-1} & 0:2 & \multicolumn{1}{|c|}{1:1} \\ \cline{1-3}
          \multicolumn{1}{|c|}{-1:-1} & 0:3 & \multicolumn{1}{|c}{ }  \\ \cline{1-2}
        \end{tabularx}
        \caption{Backpointers}
      \end{center}
    \end{subfigure}
  \end{mdframed}
  \caption{The 4 arrays used by the searching algorithm when using the candidate sets from Fig \ref{fig:candidate_nodes} and $T=1$}
  \label{fig:scoring_arrays}
\end{wrapfigure}
The search is initialized by looping over every node $n_x \in V'_0$ with a counter $j$, setting\\
\par
$indexes[0][j] = x$\par
$scores[0][j] = mappingScore(b(n_x), s_0)$\par
$backPointers[0][j] = -1:-1$\\
\par\noindent
Then the nodes $n_x \in V'_i$ for the remaining candidate sets at the indexes $1<=i<=|s|$ are looped over with $j$ as a counter, and $indexes[i][j]$ is set to $x$. For every such entry a list of pairs is made with other indexes $(i', j')$ such that $i'$ is a preceding index $i'<i$ and $j'$ is variable looping over $indexes[i']$. Every entry-pair $((i, j), (i', j'))$ can be scored by a scoring function $\theta((i, j), (i', j'))$. The scoring function works by combining the score contained in the preceding entry, $scores[i'][j']$, a gap penalty, and a mapping score for the current index $mappingScore(n_{indexes[i][j]}, s_i)$. The gap penalty is found by combining a gap penalty for a gap of length $i-i'$ and for a gap of length $distance(n_{indexes[i'][j']}, n_{indexes[i][j]})$. The final score stored in $scores[i][j]$ is the maximal achievable score $\theta$ produced by one of these pairs. $backpointers[i][j]$ is set to the to the index-pair $(i', j')$ responsible for producing this score. The recursive formulas for the three arrays are defined by:\\
\par
$indexes[i][j] = x$\quad for $n_x \in V'_i$\par
$scores[i][j] = \underset{i', j'}{max}$ $\theta((i, j), (i', j'))$\quad for $0$<=$i'$<=$i$, $0$<=$j'$<$length(scores[i'])$\par
$backPointers[i][j] = \underset{i', j'}{arg max}$ $\theta((i, j), (i', j'))$\quad \textcolor{red}{--||--}\par
\par\noindent
where $\theta$ is a scoring function defined as:\\
\par
$\theta((x_1, y_1), (x_2, y_2))=scores[x_2][y_2] + gapPenalty(x_1-x_2) +$\par$ gapPenalty(distance(n_{indexes[x_2][y_2]}, n_{indexes[x_1][y_1]})) + mappingScore(b(n_{indexes[x_1][y_1]}), s_{x_1}))$
\par\noindent
There are no restrictions in the recursive formulas to avoid alignments with aligned gaps in both the sequence and the graph. Because both gap penalties are counted the algorithm will however choose a path where only one gap is chosen in all scoring schemas where gaps are penalized with negative values, if such a path exists. By deciding the prioritized order of operations the algorithm can also handle scoring schemas with a gap penalty of $0$. Within these types of schemas, the only scenario where an alignment with aligned gaps can be produced are scenarios where there are no valid candidate nodes with context scores larger than $T$ for a subset of indexes $i$, which means there are no possible traversal of these nodes as a path which would give a score higher than $T$. This again means the path is not interesting because aligning it against the sequence would result in not mappable.
\par\noindent
There are two components of the dynamic programming algorithm where a search is performed to find possible paths: The search backwards in the indexes and the search for distances between nodes in the graph. Both of these searches can be halted whenever the resulting gap penalty exceeds the parameter $\lambda$. This means the final time complexity is much closer related to the tunable fuzzyness parameter than the size or complexity of the graph. Because of this the time complexity for the entire dynamic programming step is $O(\textcolor{red}{SOMETHING I DIDNT PUSH TO GIT})$ (See supplementary XXX \textcolor{red}{complexity analysis}).
\subsection{Handling invalid threshold values}
An invalid threshold value is in this context seen as the cases where a string $s$ is aligned against a graph $G$ with a threshold $T$, but there exists no alignments for $s$ and $G$ which produces a score higher than $T$. By the definition of the problem this should result in $s$ being unalignable which is equivalent to every element $s_x \in s$ mapping to no vertice in $G$. There are two cases in which this can happen: Either the algorithm finds an optimal path where the score is too low or there are no valid paths through $G'$. The fact that these two are the only cases can be proven by looking at their inverse: If none of the above are true there exists atleast one valid path through $G$ and the algorithm is able to find a path with a satisfactory score.\\
\par\noindent
The first of the cases provides no problems programmatically as the search is able to find alignments, score them and determine which is the best. Why can this alignment not be output as optimal? Firstly one can argue this is done in order to provide consistency regarding the definition of the problem. Another, and more convincing, argument is that the search only find the best alignment present in $G'$. Already at the point of choosing candidate nodes actual elements of the real optimal alignment can have been pruned away as a result of not having a good enough context scores. Although these alignment do not fall within the strict definition they can be utilized for heuristical applications \textcolor{red}{REF SOMEWHERE. DISCUSSION MAYBE}.\\
\par\noindent
Intuitively, the second case can be seen as instances where there are no paths from a set of startnodes indexes to a set of endnodes. Programmatically this is harder, as the edges are computed in real time. The algorithm recognices these instances when it finds a consecutive set of indexes which cannot be traversed without receiving a penalty larger than $\lambda$, and every vertice in every one of these candidate sets has no possible backpointers. Because of the possibilities of gaps at the beginning and the end of the alignment, the sets of start and endnodes can't be the candidate sets for the first and last index, but has to include all candidates for all indexes which are reachable without being penalized more than $\lambda$.
\section{Merging aligned sequences}
After aligning a sequence $s$ against a graph $G$ there exists an alignment $A$ where every element $s_x \in s$ either has a mapping to an element $v_y \in G$ or does not map to anything. If we model $s$ as a linear graph $G_s$ with a single path, where the vertices have indexes corresponding to their position in $s$ and edges corresponding to consecutive vertices, we can use the alignment as an equality relation such that $s_x \in G_s = v_y \in G \iff a_x = v_y$ to determine overlap between the vertices in $G_s$ and $G$. The merged graph $G*$ will then contain a vertice set $V_{G*}$ which is equal $V_G \cup V_{G_s}$, using the alignment as our equality determinator. Conceptually this means that every character $c$ which maps to a vertice $v$ is merged into that vertice, whereas every $c$ which does not map to anything creates a new vertice. The edges of $G*$ is created the same way, however here there are 4 possibilites: Mapped vertice to mapped vertice, unmapped vertice to mapped vertice (and its inverse) and unmapped vertice to unmapped vertice. The 3 latter cases can all be generalized to an edge which is not already existing in $G$, because one of the vertices does not exist in $G$, and the operation is thus the same. The usage of the union-operator is critical because it ensures both that all new information from the sequence is stored aswell as the fact that the graph does not lose previously seen information, which would lead to deteriation over time.
\end{document}