\documentclass[thesis.tex]{subfiles}

\begin{document}
\chapter{Method}
In this chapter we will present an algorithm for finding guaranteed optimal alignments for arbitrary reads against a graph-based reference genome given an error threshold. The notion of optimal will be defined in a more detailed specification of the problem alongside a rigorous description of the graphs involved. The PO-MSA algorithm briefly mentioned in the background has been used as a baseline in the experiments so an accurate description of the implementation of both this and the scoring matrix used is included.
\section{Overview}
\subsection{Definitions}
\begin{defn}[Graph-based reference genome (graph)]
	A pair $G=\{V,E\}$ where $V$ is a set of vertices and $E$ is a set of edges. $|G|$ denotes the number of vertices of $G$.
\end{defn}
\begin{defn}[Vertice]
	A pair $v=\{l, i\}$ where $l \in \{A, C, T, G\}$ and $i$ is a unique index. Written $v_i=l$
\end{defn}
\begin{defn}[Edge]
	An ordered pair $e=\{i_s, i_e\}$ where both elements are indexes for vertices. 
\end{defn}
\begin{defn}[Complete Path]
	An ordered list $P$ of indexes such that for all consecutive ordered pairs $\{i_x, i_{x+1}\} \in P$ there exists an edge $e=\{i_x, i_{x+1}\}$.
\end{defn}
\begin{defn}[Path]
	An ordered list $L$ of indexes such that for all consecutive ordered pairs $\{i_x, i_{x+1}\} \in L$ there exists a complete path $P$ which starts at $\{i_x\}$ and ends at $i_{x+1}\}$.
\end{defn}
\begin{defn}[Input sequence]
	A string $s$ over the alphabet $\{A, C, T, G\}$. The length of the string is given by $|s|$. An individual character on position $x$ is referenced by $s_x$
\end{defn}
\begin{defn}[Mapping score]
	A score produced by mapping two characters $c_1, c_2 \in \{A, C, G, T\}$ against a scoring matrix
\end{defn}
\begin{defn}[Path score]
	A score produced by tracersing a path $P$ through a graph $G$, scoring gaps according to the gap penalties given by a scoring schema.
\end{defn}
\begin{defn}[Alignment]
	Given a sequence $s$ and a graph $G$, a list $A$ of indexes such that every $a_x \in A$ is either a valid index for a vertice in $G$ or $0$. $0$ indicates an unmapped element of the input sequence
\end{defn}
\begin{defn}[Alignment score]
	Given a sequence $s$ a graph $G$ and an alignment $A$, the score produced by combining mapping scores for the pairs $\{a_x, s_x\} for 0<=x<|s|$ with the path score for the path(s) provided by $A$ aligned against both $G$ and $s$.
\end{defn}
\subsection{Problem definition}
Following the previous definitions the optimal alignment score-problem is defined as:\\
For any pair $\{G, s\}$ where $G$ is a graph and $s$ is a sequence, find the alignment $A$ which produces the highest alignment score.
\textcolor{red}{If multiple max scores: Provide all or chose one?}
\subsection{Scoring schema}
The algorithm is general enough to work with any scoring schema looking to maximize a score. For these experiments a variant of the Levensthein distance schema is used (as seen in \ref{fig:edit_distance_variant}), with the extension of penalizing both opening and extending a gap with -1. There is one area where the schema used deviates from a more general maximization schema: Instead of maximizing a positive score it tries to minimize a negative loss. The impact of this is discussed in \textcolor{red}{SOMEWHERE}.
\begin{wrapfigure}{r}{0.4\textwidth}
	$
	\begin{array}{r|rrrr}
	 & \mathbf{A} & \mathbf{C} & \mathbf{G} & \mathbf{T} \\ \hline
	\mathbf{A} & 0 & -1 & -1 & -1 \\
	\mathbf{C} & -1 & 0 & -1 & -1 \\
	\mathbf{G} & -1 & -1 & 0 & -1 \\
	\mathbf{T} & -1 & -1 & -1 & 0
	\end{array}
	$
	\label{fig:edit_distance_variant}
	\caption{The scoring matrix used in the experiments}
\end{wrapfigure}
\subsection{Data}
Most of the reference data used in testing is real test data borrowed from Erik Garrisons project vg\ref{REFERENCE} and the tool developed from the article \textit{Canonical, Stable, General Mapping using Context Schemes}\ref{canonical_stable_general_mapping}. Read data is generated by taking random sequences from the reference graph and introducing noise. When not specified the length of the original sequences are 60 and the probabilities of introducing a SNP, an insert or a deletion is 0.01 for each.
\subsection{PO-MSA implementation}
\section{Algorithm}

\end{document}