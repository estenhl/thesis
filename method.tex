\documentclass[thesis.tex]{subfiles}

\begin{document}
\chapter{Method}
In this chapter we will present an algorithm for finding guaranteed optimal alignments for arbitrary reads against a graph-based reference genome given an error threshold. The notion of optimal will be defined in a more detailed specification of the problem alongside a rigorous description of the graphs involved. The PO-MSA algorithm briefly mentioned in the background has been used as a baseline in the experiments so an accurate description of the implementation of both this and the scoring matrix used is included.
\section{Overview}
\subsection{Definitions}
\begin{defn}[Graph-based reference genome (graph)]
	A pair $G=\{V,E\}$ where $V$ is a set of vertices and $E$ is a set of edges. $|G|$ denotes the number of vertices of $G$.
\end{defn}
\begin{defn}[Vertice]
	A pair $v=\{b, i\}$ where $b \in \{A, C, T, G\}$ and $i$ is a unique index. Written $v_i=b$
\end{defn}
\begin{defn}[Edge]
	An ordered pair $e=\{i_s, i_e\}$ where both elements are indexes for vertices. 
\end{defn}
\begin{defn}[Complete Path]
	An ordered list $P$ of indexes such that for all consecutive ordered pairs $\{i_x, i_{x+1}\} \in P$ there exists an edge $e=\{i_x, i_{x+1}\}$.
\end{defn}
\begin{defn}[Path]
	An ordered list $L$ of indexes such that for all consecutive ordered pairs $\{i_x, i_{x+1}\} \in L$ there exists a complete path $P$ which starts at $\{i_x\}$ and ends at $i_{x+1}\}$.
\end{defn}
\begin{defn}[Input sequence]
	A string $s$ over the alphabet $\{A, C, T, G\}$. The length of the string is given by $|s|$. An individual character on position $x$ is referenced by $s_x$
\end{defn}
\begin{defn}[Mapping score]
	A score produced by mapping two characters $c_1, c_2 \in \{A, C, G, T\}$ against a scoring matrix
\end{defn}
\begin{defn}[Path score]
	A score produced by traversing a path $P$ through a graph $G$ to create a linear sequence, scoring gaps according to the gap penalties given by a scoring schema.
\end{defn}
\begin{defn}[Alignment]
	Given a sequence $s$ and a graph $G$, a list $A$ of indexes such that every $a_x \in A$ is either a valid index for a vertice in $G$ or $0$. $0$ indicates an unmapped element of the input sequence
\end{defn}
\begin{defn}[Alignment score]
	Given a sequence $s$ a graph $G$ and an alignment $A$, the score produced by combining mapping scores for the pairs $\{a_x, s_x\} for 0<=x<|s|$ with the path score for the path(s) provided by $A$ aligned against both $G$ and $s$.
\end{defn}
\begin{defn}[The optimal alignment score-problem]
	For any pair $\{G, s\}$, where $G$ is a graph and $s$ is a sequence, find the alignment $A$ which produces the highest alignment score.
	\textcolor{red}{If multiple max scores: Provide all or chose one?}
\end{defn}
\subsection{Scoring schema}
The algorithm is general enough to work with any scoring schema that yields a scoring function which is monotone in relation to the length of the input sequence. For these experiments a variant of the Levensthein distance schema is used (as seen in \ref{fig:edit_distance_variant}), with the extension of penalizing both opening and extending a gap with -1. The impact of nonincreasing vs nondecreasing scoring functions is discussed \textcolor{red}{SOMEWHERE IN THE DISCUSSION}.
\begin{wrapfigure}{r}{0.4\textwidth}
	$
	\begin{array}{r|rrrr}
	 & \mathbf{A} & \mathbf{C} & \mathbf{G} & \mathbf{T} \\ \hline
	\mathbf{A} & 0 & -1 & -1 & -1 \\
	\mathbf{C} & -1 & 0 & -1 & -1 \\
	\mathbf{G} & -1 & -1 & 0 & -1 \\
	\mathbf{T} & -1 & -1 & -1 & 0
	\end{array}
	$
	\label{fig:edit_distance_variant}
	\caption{The scoring matrix used in the experiments}
\end{wrapfigure}
\subsection{Data}
The reference data used in testing is real test data borrowed from Erik Garrisons project vg\ref{REFERENCE} and the tool developed from the article \textit{Canonical, Stable, General Mapping using Context Schemes}\ref{canonical_stable_general_mapping}. Read data is generated by taking random sequences from the reference graph and introducing noise. When not specified the length of the original sequences are 60 and the probabilities of introducing a SNP, an insert or a deletion is 0.01 for each.
\subsection{PO-MSA implementation}
\subsection{Validation}
In the results reads are categorized as either correctly or incorrectly aligned against the reference. This separation is made on based on whether the produced alignment has an alignment score higher than or equal to the alignment produced by PO-MSA. As PO-MSA is guaranteed to find an optimal score, results where the algorithm finds a better alignment then PO-MSA is interpreted as an error either in the implementation of PO-MSA or the scoring process. 
\section{Algorithm}
\subsection{Overview}
\subsection{Precomputation of the graph}
There are two data structures needed for aligning a string against the graph, a suffix tree for left contexts and a suffix tree for right contexts. Before either of the two are built the algorithm needs to decide a length for the contexts. Currently in the tool there are two ways of setting the context length: A user given parameter or an approximation based on the probability of sharing contexts \textit{red}{SUPPLEMENTARY?}. The length of a context does not impact the alignments found by the algorithm \textcolor{red}{PROOF IN SUPPLEMENTARY?} but will have an impact on the runtime. This is discussed in \textcolor{red}{DISCUSSION SOMEWHERE}\\
\par\noindent
\textcolor{red}{SOME INTRO} Two sets of strings, a left context set and a right context set, is generated for every node. The generation of the two sets happen by the same procedure, by swapping around the starting point and the direction. For a given node $n_x$ the context set $c(n_x)$ looks at every string $c \in c(n_y)$ for every neighbouring node $n_y \in neighbours(n_x)$. For every $c$ the last character is trimmed away and the character $b$ stored in the neighbour $n_y$ is added to the start. The recursion bottoms out at the startnode for the procedure which has the empty string $\epsilon$ as its only context. The algorithm has to visit every node once to generate its context. As the procedure runs twice to generate both sets the total runtime for the operation is $O(2n)$.\\
\par\noindent
\textcolor{red}{INSERTION TO SUFFIX TREE CAN BE MORE EFFICIENT}
\subsection{Creating the new graph}

\end{document}